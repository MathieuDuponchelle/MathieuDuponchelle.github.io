fragment_downloaded_cb({"url":"2020-10-09-SMPTE-2022-1-2D-Forward-Error-Correction-in-GStreamer.html#positioning-in-rtpbin","fragment":"Positioning in rtpbin\nThe decoder element is positioned upstream of rtpjitterbuffer in GStreamer's\nrtpbin. It exposes one always sinkpad for receiving media packets, and up to\ntwo request sink pads for receiving FEC packets.\n\nAll incoming packets are stored for the duration of a configurable repair\nwindow (size-time property).\nMy initial approach was to perform recovery upon retransmission requests\nemitted by rtpjitterbuffer, but this approach had multiple drawbacks:\ndo-retransmission had to be set on the jitterbuffer, which would have\nbeen confusing when retransmission was not actually required.\nrtpjitterbuffer will emit retransmission requests pretty agressively,\nand potentially multiple times for the same packet. This would have\ncaused unnecessary processing in the decoder.\nInstead, the approach I picked was to proactively reconstruct missing\npackets as soon as possible. When a FEC packet arrives, we immediately check\nwhether a media packet in the row / column it protects can be reconstructed.\nSimilarly, when a media packet comes in, we check whether we've already\nreceived a corresponding packet in both the column and row it belongs to,\nand if so go through the first step listed above.\nThis process is repeated recursively, allowing for recoveries over one\ndimension to unblock recoveries over the other.\nThe encoder exposes one sink pad, one always source pad, and two sometimes\nsource pads for pushing FEC packets. It is placed near the tail of rtpbin.\n\n\ndo-retransmission had to be set on the jitterbuffer, which would have\nbeen confusing when retransmission was not actually required.\n\n\nrtpjitterbuffer will emit retransmission requests pretty agressively,\nand potentially multiple times for the same packet. This would have\ncaused unnecessary processing in the decoder.\n\n\n"});