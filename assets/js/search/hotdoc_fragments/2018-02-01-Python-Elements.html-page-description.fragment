fragment_downloaded_cb({"url": "2018-02-01-Python-Elements.html#page-description", "fragment": "While it turns out writing meaningful elements using GStreamer through pygobject was badly broken since and it had never been possible to expose properties on said elements anyway these minor details shouldn t stop us from leveraging some of the unique and awesome packages at the disposal of the python developer from GStreamer and that s what we ll do in this series of posts. \nWriting GStreamer elements in python is usually a terrible idea \nPython is slow actual data processing should be avoided at all cost and instead delegated to C libraries such as numpy which is exactly what we ll do in this part. \nThe infamous GIL enforces serialization which means python elements will not be able to take advantage of the multithreading capabilities of modern platforms. \nThe only valid reasons for ignoring these restrictions are to the best of my knowledge \nPython is the only language you know how to use. \nYou want to use a python package that has no equivalent elsewhere for example for scientific computing. \nPython rocks and you don t intend to do anything CPU intensive anyway. \nAll of the above. \nThe obvious recommendation these days if you do not want to deal with low level concerns such as data races and memory safety is Rust. More information can be found here and in this series of posts from Sebastian Dr ge. \nTo make that element available assuming gst python is installed the code above needs to be placed in a python directory anywhere gstreamer will look for plugins eg GST_PLUGIN_PATH \nAt the moment of writing the master branches from both pygobject and gstreamer need to be installed. \nLet s study some of the interesting parts now. \nNothing unfamiliar here assuming you ve already done some pygobject programming note that unlike an application that would usually initialize GStreamer here with a call to Gst.init we don t need to do that. \nWe will use numpy to generate samples in a reasonably efficient manner more on that below. \nUsing gst python we implement new elements as python classes which we need to register with GStreamer. The python plugin loader implemented by gst python will import our module and look for an attribute with the well known name __gstelementfactory__. \nThe value of this attribute should be a tuple consisting of a factory name a rank and the class that implements the element. \nIf the module needs to register multiple elements it can do so by assigning a tuple of such tuples instead. \nThe class that we register is expected to hold a __gstmetadata__ class attribute \nThe contents of this tuple will be used to call gst_element_class_set_metadata you ll find more information in its documentation \nOur element will be a GStreamer source it will not have any sink pads and will output data on a single source pad. \nThere is a base class in GStreamer for that type of elements GstBase.BaseSrc. It handles state changes supports live sources push and pull mode scheduling and more. \nInheritance is standard the subclass needs to chain up in its __init__ function if it implements it. \nOverriding virtual methods can be done by prefixing the name of the virtual method as declared in C with do_ more on that later. \nThe __init__ method should obviously only be called once over the lifetime of the element. \nThis means we only need to initialize here those variables that will not need to be reinitialized when the element switches states. We only declare and re initialize other variables in the do_start virtual method implementation. \nNote that linters might complain when attributes are declared outside of the __init__ function as we do in the do_start virtual method if you wish to strictly comply you will want to declare them in __init__ as well we didn t do so here for the sake of brevity. \nAs our base class declares a start vmethod we implement it by defining a do_start method in our class. \nIn this example we implement an element that will only output a single format \n__gsttemplates__ is another well known name that the python plugin loader will look up it matches the arguments to gst_pad_template_new here we declare that we will expose a single source pad named src that will output data in the format specified by OCAPS channels of interleaved float samples at a rate of audio frames so samples a second. \nAs that format is fixed we won t have to concern ourselves with negotiation in that element this will be automatically handled by our parent classes. \nWe technically could have done this directly in __init__ as we already know what the result of the negotiation will be however if in the future we decided to make things more dynamic for example by supporting multiple sample formats the audio info would need to be initialized at the end of the negotiation process as we do here. \nThe next blog post in this series will present an element implementing dynamic negotiation a good exercise for the reader could be to port this element to support a range of supported output channels or a second sample format eg bit integers. \nWe chose to generate samples in our do_create implementation for no particular reason the default implementation would call do_alloc then do_fill we should only have to implement the latter if we wished to use that approach as we have called GstBase.BaseSrc.set_blocksize in our set_caps implementation. \nI will not discuss the implementation details here we generate an array of float samples forming a sine wave using numpy and keep track of where the waveform was at in the accumulator attribute this is all pretty simple stuff. \nWe could of course generate the samples in a for loop but performance would be abysmal. \nThe interesting part here is that GstBaseSrc expects us to return a tuple made of Gst.FlowReturn.OK output_buffer if everything went well otherwise typically Gst.FlowReturn.ERROR None if there was an issue generating the data. \nIt is the responsability of the create vmethod implementation to create the output buffer which is just what we do with Gst.Buffer.new_wrapped bytes data \nIt is possible with pygobject to declare GObject properties with a decorator however if one wants to specify minimum maximum or default values or provide some documentation to be for example presented in the gst inspect output one needs to use a more verbose form \nSome interesting improvements here could be to declare the freq property as controllable or expose a property allowing to change the shape of the waveform sine square triangle \nThree things are needed to output data in live mode \nCalling GstBase.BaseSrc.set_live True \nReporting the latency by handling the LATENCY query which is what we do in do_gst_base_src_query. The attentive reader might have noticed that even though the GstBaseSrc virtual method is named query we didn t implement it as do_query that is because GstElement also exposes a virtual method with the same name and we have to lift the ambiguity. Try implementing do_query and see what happens. \nImplementing get_times to let the base class know when it should actually push the buffer out. \nOur element does all three things and exposes a property named is live to control that behaviour you can verify it as follows \nas opposed to \nWe have implemented a simplified version of audiotestsrc here the reader can update the code to support more features and familiarize themselves with the GstBaseSrc API or alternatively try to implement a video test src. \nIn the next post we will present a GstBaseTransform implementation that accepts audio as an input and outputs a plot generated with matplotlib. There will be dynamic negotiation decoupling of the input and output and more interesting things. \n"});