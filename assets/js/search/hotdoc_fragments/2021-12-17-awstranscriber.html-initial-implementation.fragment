fragment_downloaded_cb({"url":"2021-12-17-awstranscriber.html#initial-implementation","fragment":"Initial implementation\nWhen I initially implemented the element, the Transcribe API had a pretty\nsignificant flaw for my use case: while it provided me with \"partial\" results,\nwhich sounded great for lowering the latency, there was no way to identify\npartial results between messages.\nHere's an illustration (this is just an example, the actual output is more\ncomplex).\nAfter feeding five seconds of audio data to the service, I would receive a first\nmessage:\nThen after one more second I would receive:\nand so on, until the service decided it was done with the sentence and started a\nnew one. There were multiple problems with this, compounding each other:\nThe service seemed to have no predictable \"cut-off\" point, that is it would sometimes\nprovide me with 30-second long sentences before considering it finished (partial: false)\nand starting a new one.\nAs long as a result was partial, the service could change any of the words it had\npreviously detected, even if they were first reported 10 seconds prior.\nThe actual timing of the items could also shift (slightly)\nThis made the task of outputting one word at a time, just in time to honor the user-provided\nlatency, seemingly impossible: as items could not be strictly identified from one\npartial result to the next, I could not tell whether a given word whose end time matched with\nthe running time of the element had already been pushed or had been replaced with\na new interpretation by the service.\nContinuing with the above example, and admitting a 10-second latency, I could\ndecide at 9 seconds running time to push \"Hello\", but then receive a new partial\nresult:\nWhat to then do with that \"Hey\"? Was it a new word that ought to be pushed?\nAn old one with a new meaning arrived too late that ought to be discarded?\nArtificial intelligence attempting first contact?\nFortunately, after some head scratching and ~~some~~lots of blankly looking at the\nJSON, I noticed a behavior which while undocumented seemed to always hold true:\nwhile any feature of an item could change, the start time would never grow past\nits initial value.\nGiven that, I finally managed to write some quite convoluted code that ended up\nyielding useful results, though punctuation was very hit and miss, and needed some\nmore complex conditions to (sometimes) get output.\nYou can still see that code in all its glory here, I'm happy to say that it\nis gone now!\n\n\nThe service seemed to have no predictable \"cut-off\" point, that is it would sometimes\nprovide me with 30-second long sentences before considering it finished (partial: false)\nand starting a new one.\n\n\nAs long as a result was partial, the service could change any of the words it had\npreviously detected, even if they were first reported 10 seconds prior.\n\n\nThe actual timing of the items could also shift (slightly)\n\n\n"});